private int lastTradeBar = -100; 
private int cooldownBars = 10;   
private int longSignalCount = 0;  // Counter for long signals
private int shortSignalCount = 0; // Counter for short signals
private int requiredSignals = 3;  // Number of signals required before execution

protected override void OnBarUpdate()
{
    loggingId = Account.Name + " " + Instrument.FullName;
    unrealizedProfitLoss = Account.Get(AccountItem.UnrealizedProfitLoss, Currency.UsDollar);

    if (CurrentBar < Period) return; // Ensure enough bars are available

    // Enforce cooldown: No new trades if within cooldown period
    if ((CurrentBar - lastTradeBar) < cooldownBars) return;

    double lower = regressionChannel.Lower[0];
    double upper = regressionChannel.Upper[0];
    double middle = regressionChannel.Middle[0];

    // Improved slope calculation (5-bar lookback)
    if (CurrentBar > Period)
    {
        slope = (regressionChannel.Middle[0] - regressionChannel.Middle[5]) / 5;
    }

    // **Exit Logic (Stops and Take Profits)**
    if (unrealizedProfitLoss >= 200)
    {
        if (Position.MarketPosition == MarketPosition.Long)
        {
            ExitLong(1);
        }
        if (Position.MarketPosition == MarketPosition.Short)
        {
            ExitShort(1);
        }
        lastTradeBar = CurrentBar; 
    }

    // Exit long if price crosses below middle or upper band
    if (Position.MarketPosition == MarketPosition.Long && 
        (CrossBelow(Close, upper, 1) || CrossBelow(Close, middle, 1)))
    {
        ExitLong(1);
        lastTradeBar = CurrentBar; 
    }

    // Exit short if price crosses above middle or lower band
    if (Position.MarketPosition == MarketPosition.Short && 
        (CrossAbove(Close, lower, 1) || CrossAbove(Close, middle, 1)))
    {
        ExitShort(1);
        lastTradeBar = CurrentBar;
    }

    // **Entry Logic (Wait for 3 Signals Before Executing Trade)**

    // **Long Signal Detection**
    if (CrossAbove(Close, lower, 1) && slope >= -0.3) 
    {
        longSignalCount++;  // Increment long signal counter
        Print($"Long Signal Count: {longSignalCount}");

        if (longSignalCount >= requiredSignals) // Only enter on 3rd signal
        {
            if (Position.MarketPosition == MarketPosition.Short && unrealizedProfitLoss >= 100)
            {
                ExitShort(1);
            }
            else
            {
                EnterLong(3, "Long_Entry");
                lastTradeBar = CurrentBar; 
                longSignalCount = 0;  // Reset counter after execution
                Print($"{loggingId} Executed Long Trade on 3rd Signal");
            }
        }
    }
    else
    {
        longSignalCount = 0;  // Reset if condition is not met consecutively
    }

    // **Short Signal Detection**
    if (CrossBelow(Close, upper, 1) && slope <= 0.3) 
    {
        shortSignalCount++;  // Increment short signal counter
        Print($"Short Signal Count: {shortSignalCount}");

        if (shortSignalCount >= requiredSignals) // Only enter on 3rd signal
        {
            if (Position.MarketPosition == MarketPosition.Long && unrealizedProfitLoss >= 100)
            {
                ExitLong(1);
            }
            else
            {
                EnterShort(3, "Short_Entry");
                lastTradeBar = CurrentBar; 
                shortSignalCount = 0;  // Reset counter after execution
                Print($"{loggingId} Executed Short Trade on 3rd Signal");
            }
        }
    }
    else
    {
        shortSignalCount = 0;  // Reset if condition is not met consecutively
    }
}
